module Web
  module Controllers
    # Controller to handle all routes relating to a specific module.
    class Module < Base
      helpers Web::Helpers::OptionsHelper

      use Rack::PostBodyContentTypeParser

      get '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        json(
          title: mod.module_name,
          desc: mod.module_desc,
          references: inflated_references(mod.module_references),
          authors: mod.module_author,
          date: mod.module_date,
          options: options_hash(mod.options),
          path: "#{params['type']}/#{params['name']}"
        )
      end

      post '/:type/:name' do
        halt unless params['type'].eql?('exploit') || params['type'].eql?('auxiliary')
        mod = load_module(params['type'], params['name'])
        halt 404 if mod.nil?

        unless params['options'].nil?
          params['options'].each do |opt|
            mod.set_option_value(opt['name'], opt['value'])
          end
        end

        unless params['payload'].nil? || params['payload'].empty?
          mod.payload = load_payload(params['payload']['name'])
          params['payload']['options'].each do |opt|
            mod.payload.set_option_value(opt['name'], opt['value'])
          end
        end

        halt 500, { 'Content-Type' => 'application/json' }, json(success: false) unless can_execute?(mod)
        session = create_new_session(params['type'], params['name'], mod)
        json 'success' => true, 'session_id' => session.id
      end

      private

      def can_execute?(mod)
        mod.can_execute? && (mod.payload.nil? || (mod.payload && mod.payload.prepare(mod)))
      end

      def inflated_references(references)
        return if references.nil?
        references.map do |ref|
          Wpxf::Utility::ReferenceInflater.new(ref[0]).inflate(ref[1])
        end
      end

      def load_module(type, name)
        class_name = Wpxf.path_to_class_name(name)
        namespace = type.eql?('exploit') ? Wpxf::Exploit : Wpxf::Auxiliary
        return namespace.const_get(class_name).new
      rescue NameError
        return nil
      end

      def load_payload(name)
        class_name = Wpxf.path_to_class_name(name)
        payload = Wpxf::Payloads.const_get(class_name).new
        payload.context = :web
        return payload
      rescue NameError
        return nil
      end

      def create_new_session(type, name, mod)
        session = Web::Models::Session.create(module_path: "#{type}/#{name}")
        listener = Web::Helpers::WebSessionOutputHelper.new(session)

        thread = Thread.new do
          mod.event_emitter.subscribe(listener)
          success = false

          begin
            success = mod.run && (!mod.payload || mod.payload.post_exploit(mod))
          rescue StandardError => e
            mod.emit_error "Uncaught error: #{e}"
            mod.emit_error e.backtrace.join("\n\t")
          end

          if success
            mod.emit_success 'Execution finished successfully'
          else
            mod.emit_error 'Execution failed'
          end

          mod.cleanup
        end

        Sessions.active_sessions.push(id: session.id, module: mod, thread: thread)
        session
      end
    end
  end
end
